#!/usr/bin/env python3
"""
Extract hierarchical structure from Avathon API specification.
Maps each tool to its category hierarchy based on OpenAPI tags.
"""

import json
import os
import sys
from typing import Dict, List, Set
from collections import defaultdict

# Add parent directories to path to handle imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from toolset import AVATHON_EXECUTION_REGISTRY


def extract_hierarchy_from_specs():
    """Extract tool hierarchy from Avathon OpenAPI specification."""
    
    # Load the OAS spec
    spec_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'specs', 'avathon_OAS.json')
    with open(spec_path, 'r') as f:
        spec = json.load(f)
    
    # Map operationId to tags (hierarchy)
    operation_to_tags = {}
    
    for path, path_item in spec.get('paths', {}).items():
        for method in ['get', 'post', 'put', 'patch', 'delete']:
            if method in path_item:
                operation = path_item[method]
                operation_id = operation.get('operationId')
                tags = operation.get('tags', [])
                
                if operation_id and tags:
                    # Use the first tag as the primary category
                    # Store both original and variations for matching
                    operation_to_tags[operation_id] = tags[0] if tags else None
                    operation_to_tags[operation_id.lower()] = tags[0] if tags else None
    
    return operation_to_tags


def infer_category_from_name(tool_name: str) -> str:
    """Infer category from tool name if not found in OpenAPI tags."""
    name_lower = tool_name.lower()
    
    # Avathon-specific category inference
    if any(term in name_lower for term in ['health', 'predict']):
        return 'Predict'
    elif any(term in name_lower for term in ['alarm', 'alert']):
        return 'Alarms'
    elif any(term in name_lower for term in ['performance', 'ratio']):
        return 'Asset Performance'
    elif any(term in name_lower for term in ['forecast']):
        return 'Forecast'
    elif any(term in name_lower for term in ['component', 'inventory', 'ticket']):
        return 'Maintain'
    elif any(term in name_lower for term in ['notification']):
        return 'Notifications'
    elif any(term in name_lower for term in ['gpm', 'plant']):
        return 'GPM General'
    elif any(term in name_lower for term in ['raw', 'historian']):
        return 'Raw Data'
    elif any(term in name_lower for term in ['solar', 'dc']):
        return 'Solar'
    elif any(term in name_lower for term in ['wind', 'power']):
        return 'Wind'
    elif any(term in name_lower for term in ['data', 'query']):
        return 'Data'
    else:
        return 'General'


def build_tool_hierarchy():
    """Build complete tool hierarchy mapping each tool to its category path."""
    
    operation_to_tags = extract_hierarchy_from_specs()
    
    # Load the display names (generated by generate_human_readable_tools.py)
    display_path = os.path.join(os.path.dirname(__file__), 'avathon_tools_display.json')
    
    if not os.path.exists(display_path):
        print(f"❌ Display names file not found: {display_path}")
        print("Run generate_human_readable_tools.py first to create display names")
        sys.exit(1)
    
    with open(display_path, 'r') as f:
        display_tools = json.load(f)
    
    # Create hierarchy structure
    categorized_tools = []
    uncategorized_tools = []
    
    # Process each tool
    for tool in display_tools:
        tool_name = tool['name']
        
        # Try to find the tag for this tool
        tag = operation_to_tags.get(tool_name)
        
        if tag:
            # For Avathon, tags are typically single-level (not hierarchical like Procore)
            # But we can still create structure
            parts = tag.split('/') if '/' in tag else [tag]
            category_path = parts
            
            categorized_tools.append({
                **tool,
                'category': parts[0] if parts else 'Other',
                'subcategory': parts[1] if len(parts) > 1 else 'General',
                'endpoint_group': parts[2] if len(parts) > 2 else 'General',
                'full_path': tag
            })
        else:
            # Tool not found in OAS, infer from name
            category = infer_category_from_name(tool_name)
            uncategorized_tools.append({
                **tool,
                'category': category,
                'subcategory': 'General',
                'endpoint_group': 'General',
                'full_path': category
            })
    
    # Build simplified tree structure (flat categories for Avathon)
    hierarchy = defaultdict(list)
    
    # Add all tools to their categories
    for tool in categorized_tools + uncategorized_tools:
        category = tool['category']
        
        hierarchy[category].append({
            'name': tool['name'],
            'display_name': tool['display_name'],
            'description': tool['description']
        })
    
    # Convert defaultdict to regular dict for JSON serialization
    hierarchy = dict(hierarchy)
    
    # Generate category names list
    category_names = sorted(hierarchy.keys())
    
    # Calculate statistics
    total_tools = len(categorized_tools) + len(uncategorized_tools)
    stats = {
        'total_tools': total_tools,
        'categorized': len(categorized_tools),
        'uncategorized': len(uncategorized_tools),
        'categories': len(category_names),
        'category_names': category_names
    }
    
    return {
        'hierarchy': hierarchy,
        'category_names': category_names,
        'stats': stats,
        'tools': categorized_tools + uncategorized_tools
    }


def main():
    """Generate tool hierarchy and category names JSON files."""
    print("🧪 Extracting Avathon tool hierarchy...")
    
    hierarchy_data = build_tool_hierarchy()
    
    # Save tool hierarchy
    hierarchy_output = os.path.join(os.path.dirname(__file__), 'tool_hierarchy.json')
    with open(hierarchy_output, 'w') as f:
        json.dump(hierarchy_data['hierarchy'], f, indent=2)
    
    # Save category names
    categories_output = os.path.join(os.path.dirname(__file__), 'category_names.json')
    with open(categories_output, 'w') as f:
        json.dump(hierarchy_data['category_names'], f, indent=2)
    
    # Print summary
    stats = hierarchy_data['stats']
    print(f"\n✅ Processed {stats['total_tools']} tools")
    print(f"   • Categorized: {stats['categorized']}")
    print(f"   • Uncategorized: {stats['uncategorized']}")
    print(f"   • Categories: {stats['categories']}")
    
    print(f"\n📋 Categories found:")
    for category in stats['category_names']:
        category_tools = []
        for tool in hierarchy_data['tools']:
            if tool['category'] == category:
                category_tools.append(tool['name'])
        print(f"   • {category}: {len(category_tools)} tools")
    
    print(f"\n📄 Files generated:")
    print(f"   • Tool hierarchy: {hierarchy_output}")
    print(f"   • Category names: {categories_output}")
    
    print(f"\n🎉 Avathon tool hierarchy extraction complete!")


if __name__ == "__main__":
    main()